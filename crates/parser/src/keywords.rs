use std::fmt;

/// SQL Keywords supported by the parser.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Keyword {
    Select,
    Distinct,
    From,
    Where,
    Insert,
    Into,
    Update,
    Delete,
    Create,
    Table,
    Drop,
    Alter,
    And,
    Or,
    Not,
    Null,
    True,
    False,
    As,
    Join,
    Left,
    Right,
    Inner,
    Outer,
    On,
    Group,
    By,
    Having,
    Order,
    Asc,
    Desc,
    Limit,
    Offset,
    Set,
    Values,
    In,
    Between,
    Like,
    Exists,
    All,
    Any,
    Some,
    Union,
    Intersect,
    Except,
    With,
    Date,
    Time,
    Timestamp,
    Interval,
    Cast,
    // Window function keywords
    Over,
    Partition,
    Rows,
    Range,
    Preceding,
    Following,
    Unbounded,
    Current,
    // Window function names
    RowNumber,
    Rank,
    DenseRank,
    Ntile,
    Lag,
    Lead,
}

impl fmt::Display for Keyword {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let keyword_str = match self {
            Keyword::Select => "SELECT",
            Keyword::Distinct => "DISTINCT",
            Keyword::From => "FROM",
            Keyword::Where => "WHERE",
            Keyword::Insert => "INSERT",
            Keyword::Into => "INTO",
            Keyword::Update => "UPDATE",
            Keyword::Delete => "DELETE",
            Keyword::Create => "CREATE",
            Keyword::Table => "TABLE",
            Keyword::Drop => "DROP",
            Keyword::Alter => "ALTER",
            Keyword::And => "AND",
            Keyword::Or => "OR",
            Keyword::Not => "NOT",
            Keyword::Null => "NULL",
            Keyword::True => "TRUE",
            Keyword::False => "FALSE",
            Keyword::As => "AS",
            Keyword::Join => "JOIN",
            Keyword::Left => "LEFT",
            Keyword::Right => "RIGHT",
            Keyword::Inner => "INNER",
            Keyword::Outer => "OUTER",
            Keyword::On => "ON",
            Keyword::Group => "GROUP",
            Keyword::By => "BY",
            Keyword::Having => "HAVING",
            Keyword::Order => "ORDER",
            Keyword::Asc => "ASC",
            Keyword::Desc => "DESC",
            Keyword::Limit => "LIMIT",
            Keyword::Offset => "OFFSET",
            Keyword::Set => "SET",
            Keyword::Values => "VALUES",
            Keyword::In => "IN",
            Keyword::Between => "BETWEEN",
            Keyword::Like => "LIKE",
            Keyword::Exists => "EXISTS",
            Keyword::All => "ALL",
            Keyword::Any => "ANY",
            Keyword::Some => "SOME",
            Keyword::Union => "UNION",
            Keyword::Intersect => "INTERSECT",
            Keyword::Except => "EXCEPT",
            Keyword::With => "WITH",
            Keyword::Date => "DATE",
            Keyword::Time => "TIME",
            Keyword::Timestamp => "TIMESTAMP",
            Keyword::Interval => "INTERVAL",
            Keyword::Cast => "CAST",
            Keyword::Over => "OVER",
            Keyword::Partition => "PARTITION",
            Keyword::Rows => "ROWS",
            Keyword::Range => "RANGE",
            Keyword::Preceding => "PRECEDING",
            Keyword::Following => "FOLLOWING",
            Keyword::Unbounded => "UNBOUNDED",
            Keyword::Current => "CURRENT",
            Keyword::RowNumber => "ROW_NUMBER",
            Keyword::Rank => "RANK",
            Keyword::DenseRank => "DENSE_RANK",
            Keyword::Ntile => "NTILE",
            Keyword::Lag => "LAG",
            Keyword::Lead => "LEAD",
        };
        write!(f, "{}", keyword_str)
    }
}
