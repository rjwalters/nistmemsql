# VibeSQL: AI-Powered SQL:1999 Database

[![CI and Deploy](https://github.com/rjwalters/vibesql/actions/workflows/ci-and-deploy.yml/badge.svg)](https://github.com/rjwalters/vibesql/actions/workflows/ci-and-deploy.yml)
[![Demo](https://img.shields.io/badge/demo-live-success)](https://rjwalters.github.io/vibesql/)
[![Coverage](https://img.shields.io/badge/coverage-86%25-green)](https://github.com/rjwalters/vibesql)
[![sqltest](https://img.shields.io/endpoint?url=https://rjwalters.github.io/vibesql/badges/sql1999-conformance.json)](https://rjwalters.github.io/vibesql/conformance.html)
[![SQLLogicTest](https://img.shields.io/endpoint?url=https://rjwalters.github.io/vibesql/badges/sqllogictest.json)](https://rjwalters.github.io/vibesql/conformance.html#SQLlogicTest)

> **VibeSQL - AI-powered, SQL:1999 database implementation in Rust**

üöÄ **[Try the Live Demo](https://rjwalters.github.io/vibesql/)** - Run SQL queries in your browser!

üíª **[Use the CLI](#interactive-sql-shell)** - Full-featured interactive SQL shell with import/export, multiple output formats, and PostgreSQL-compatible meta-commands!

---

## üéØ Project Vision

Build a **FULL SQL:1999 compliant** database from scratch, designed for NIST conformance testing. This is a research and educational project targeting complete standard compliance‚Äîsomething no production database has achieved.

### Achievement

**‚úÖ Core SQL:1999 Compliance - COMPLETE!**
- All ~169 mandatory Core features implemented
- 100% sqltest conformance (739/739 tests passing)
- Completed in under 2 weeks (Oct 25 - Nov 1, 2025)

**üöß Current Focus: Extended SQL:1999 Compliance**
- Implementing optional features beyond Core
- Progressive SQLLogicTest coverage (~5.9M tests)
- Inspired by the [posix4e/nistmemsql challenge](https://github.com/posix4e/nistmemsql)

---

## ü§ñ 100% AI-Generated

Every line of code, every test, and all documentation in this repository has been generated by AI agents using [Claude Code](https://claude.com/claude-code) and the [Loom orchestration framework](https://github.com/loomhq/loom).

**What was built:**
- üìä **65,000+ lines** of production Rust code
- ‚úÖ **2,000+ passing tests** with 86% coverage
- üéØ **100% SQL:1999 Core compliance** (739/739 tests)
- üöÄ **Full WASM compilation** with live browser demo
- üèóÔ∏è **AI Builder/Judge workflow** with automated PR reviews
- üîí **Complete security model** with privilege enforcement

This demonstrates AI-primary development at scale‚Äîhigh-level intent translated directly into working, tested, standards-compliant software.

Learn more: [Loom documentation](https://github.com/loomhq/loom) and [working with AI](https://github.com/rjwalters/loom/blob/main/docs/philosophy/working-with-ai.md).

---

## üìä SQL:1999 Conformance Testing

We use comprehensive test suites to track SQL:1999 compliance:

### Test Suites
- **sqltest**: 739 BNF-driven tests from SQL:1999 standard (upstream-recommended)
- **Custom tests**: 2,000+ end-to-end integration tests for specific features
- **SQLLogicTest**: ~5.9 million tests from official SQLite corpus (623 test files)

### Current Conformance Status

| Suite | Tests | Status |
|-------|-------|--------|
| SQL:1999 sqltest | 739 tests | ‚úÖ **100% (739 passing)** |
| Custom E2E Tests | 2,000+ tests | ‚úÖ **100% passing** |
| SQLLogicTest | 623 test files (~5.9M tests) | üîÑ **Progressive coverage** - See badge above (cumulative from all CI + boost runs) |

**Major Features Implemented:**
- ‚úÖ **100% SQL:1999 Core Conformance** - All 739 sqltest tests passing
- ‚úÖ **Full-featured CLI** - Interactive REPL with PostgreSQL-compatible meta-commands
- ‚úÖ **Import/Export** - CSV and JSON support with \copy command
- ‚úÖ **Multiple output formats** - Table, JSON, CSV, Markdown, HTML
- ‚úÖ **Complete security model** - GRANT/REVOKE with full privilege enforcement
- ‚úÖ **Performance optimizations** - Hash join, expression optimization, memory improvements
- ‚úÖ **SQLLogicTest integration** - ~5.9M tests for comprehensive validation

**See [SQL:1999 Conformance Report](https://rjwalters.github.io/vibesql/conformance.html) for detailed test results and remaining work.**

### üêï Dogfooding: SQLLogicTest Database Integration (NEW!)

**VibeSQL now stores its own test results in VibeSQL!** We've implemented a complete database-integrated workflow for SQLLogicTest, demonstrating real-world usage.

**Quick Start**:
```bash
# Run tests (database auto-updates)
./scripts/sqllogictest run --time 60

# Query results with SQL!
./scripts/sqllogictest query --preset failed-files
./scripts/sqllogictest query --preset by-category

# Custom queries
./scripts/sqllogictest query --query "
    SELECT category, COUNT(*) FROM test_files
    WHERE status='FAIL' GROUP BY category
"
```

**Features**:
- üìä **3 tables**: test_files, test_runs, test_results
- üîç **9 preset queries**: failed-files, by-category, progress, flaky-tests, etc.
- üìà **Historical tracking**: Track pass rate over time with git commits
- üéØ **Manual testing workflow**: Query your progress as you work through tests

**Documentation**:
- [Quick Start Guide](docs/sqllogictest/SQLLOGICTEST_QUICKSTART.md) - 30-second introduction
- [Complete Documentation](docs/sqllogictest/SQLLOGICTEST_DATABASE.md) - Architecture, schema, queries, workflow

### Running Tests

```bash
# Run all tests with coverage
cargo coverage

# Run SQL:1999 conformance tests
cargo test --test sqltest_conformance -- --nocapture

# Run SQLLogicTest baseline verification
cargo test --test sqllogictest_basic

# Run comprehensive SQLLogicTest suite with 5-minute time budget
SQLLOGICTEST_TIME_BUDGET=300 cargo test --test sqllogictest_suite --release -- --nocapture
```

**SQLLogicTest Systematic Testing Strategy**: The suite contains ~5.9 million test cases across 623 files. We use a **systematic punchlist approach** to achieve 100% conformance:

- **Punchlist system**: Comprehensive tracking of all 623 test files by category and status
- **Manual testing**: Test files one at a time to identify and fix root causes
- **Badge updates**: Shows `{passed}‚úì {failed}‚úó {untested}? ({pass_rate}%)`
- **Progress tracking**: All results tracked in `target/sqllogictest_punchlist.json`

To test individual files and track progress:
```bash
# Test a specific file
./scripts/test_one_file.sh index/delete/10/slt_good_0.test

# Regenerate punchlist after fixes
python3 scripts/generate_punchlist.py

# View progress
cat target/sqllogictest_punchlist.csv
```

See [`docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md`](docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md) for the complete strategic guide.

### SQLLogicTest Conformance Punchlist

To systematically track progress toward 100% SQLLogicTest conformance, we've created a comprehensive punchlist system:

**Quick Start**:
```bash
# Read the strategic guide
cat docs/sqllogictest/QUICK_START.md

# View the full punchlist
cat target/sqllogictest_punchlist.csv

# Test a single file to understand the current failures
./scripts/test_one_file.sh index/delete/10/slt_good_0.test

# Refresh the punchlist after fixes
python3 scripts/generate_punchlist.py
```

**Documentation**:
- **[docs/sqllogictest/QUICK_START.md](docs/sqllogictest/QUICK_START.md)** - 2-minute overview with key commands
- **[docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md](docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md)** - Full strategic guide with workflow and phase breakdown
- **[docs/roadmaps/PUNCHLIST_README.md](docs/roadmaps/PUNCHLIST_README.md)** - Complete setup documentation and detailed instructions
- **[docs/roadmaps/PUNCHLIST_MANIFEST.md](docs/roadmaps/PUNCHLIST_MANIFEST.md)** - Manifest of all deliverables and their purposes
- **[.loom/punchlist_guide.md](.loom/punchlist_guide.md)** - Builder-specific reference for implementing fixes

**Current Status**:
| Category | Total | Passing | % | Priority |
|----------|-------|---------|---|----------|
| index | 214 | 75 | 35.0% | üî¥ High - Best opportunity for quick wins |
| evidence | 12 | 6 | 50.0% | üü° Medium |
| random | 391 | 2 | 0.5% | üü† High volume, harder issues |
| ddl | 1 | 0 | 0.0% | Low |
| **TOTAL** | **623** | **83** | **13.3%** | ‚Üí Goal: 100% |

---

## üìä Performance Benchmarking

VibeSQL includes a comprehensive benchmark framework for comparing performance against SQLite3. Track performance metrics, identify regressions, and validate optimizations.

### Quick Start

```bash
# Run simple benchmark test
cargo test --test sqllogictest_suite -- benchmarks/simple --nocapture

# Run benchmark suite
cargo test --test sqllogictest_suite -- benchmarks/ --nocapture
```

### Features

- **Dual-engine comparison**: Run the same tests on VibeSQL and SQLite
- **Comprehensive metrics**: Time, memory, query counts, pass rates
- **Multiple output formats**: Console, JSON, Markdown
- **Statistical analysis**: Percentiles (p50, p95, p99), ratios, aggregates

### Example Output

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         VibeSQL vs SQLite Performance Report         ‚îÇ
‚îÇ                   select1.test                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Summary:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Metric         ‚îÇ SQLite    ‚îÇ VibeSQL  ‚îÇ Ratio   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Total Time     ‚îÇ 1.23s     ‚îÇ 2.45s    ‚îÇ 1.99x   ‚îÇ
‚îÇ Peak Memory    ‚îÇ 10.2 MB   ‚îÇ 25.5 MB  ‚îÇ 2.50x   ‚îÇ
‚îÇ Queries/Sec    ‚îÇ 812       ‚îÇ 408      ‚îÇ 0.50x   ‚îÇ
‚îÇ Pass Rate      ‚îÇ 100.0%    ‚îÇ 100.0%   ‚îÇ +0.0pp  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Performance Goals

- **SELECT queries**: Within 2-3x of SQLite
- **INSERT/UPDATE/DELETE**: Within 2x of SQLite
- **Joins**: Within 3x of SQLite
- **100% conformance**: Identical results on supported features

### Documentation

See [docs/BENCHMARKING.md](docs/BENCHMARKING.md) for:
- Complete API reference
- Writing benchmark tests
- Interpreting results
- CI integration guide
- Performance optimization tips

---

## üí≠ Project Background

This project originated from a debate about AI capabilities in software development. [@rjwalters](https://github.com/rjwalters) argued that AI assistants like Claude Code have crossed an **inflection point** for complex software implementation. [@posix4e](https://github.com/posix4e) was skeptical, citing context window limitations.

The challenge: **"Implement a NIST-compatible SQL database from scratch."**

### Results

**‚úÖ Core SQL:1999 compliance achieved in under 2 weeks** (Oct 25 - Nov 1, 2025)
- 100% sqltest conformance (739/739 tests)
- 2,000+ unit/integration tests
- Complete query engine with all major SQL features
- Full transaction and constraint support
- Production-grade security model

### What This Demonstrates

- AI can handle complex, specification-driven projects
- Context window concerns can be managed with proper tooling ([Loom](https://github.com/loomhq/loom))
- Tedious, detail-oriented work (like SQL standard compliance) is well-suited to AI
- Productivity gains are orders of magnitude higher than traditional development

See [Working with AI](https://github.com/rjwalters/loom/blob/main/docs/philosophy/working-with-ai.md) for more on the philosophy.

---

## üó∫Ô∏è Roadmap

### ‚úÖ Core SQL:1999 Compliance - COMPLETE

**Achieved**: November 1, 2025 (Under 2 weeks from start)
- 100% sqltest conformance (739/739 tests)
- Complete query engine with all major SQL features
- Full transaction and constraint support
- Production-grade security model

### üöß Current Focus: Extended Compliance

**SQLLogicTest Coverage**
- Progressive implementation of ~5.9M test cases
- Systematic punchlist approach for 623 test files
- Focus on index operations, random queries, and edge cases

**Optional SQL:1999 Features**
- Information schema views
- Advanced optimization techniques
- Additional built-in functions

### üéØ Future Directions

**Path 1: Full SQL:1999 Compliance**
- Advanced type system (ARRAY, ROW, UDT, BLOB, CLOB)
- Procedural SQL (stored procedures, functions, cursors)
- Triggers (BEFORE/AFTER, row/statement level)
- Advanced DDL (domains, assertions, character sets, collations)
- Goal: First database with complete SQL:1999 compliance

**Path 2: Production Readiness**
- ODBC/JDBC drivers
- Network protocol support
- Persistence layer
- Advanced optimization
- Production hardening

**Path 3: Real-World Validation**
- TPC-H benchmarks
- Production workload testing
- Performance optimization
- Scalability improvements

---

## üåê Live Demo

**[Try it now ‚Üí](https://rjwalters.github.io/vibesql/)**

Run SQL queries directly in your browser with **zero setup**:
- **Pre-loaded Sample Data** - 6 employee records ready to query
- **Instant Execution** - Press Ctrl/Cmd+Enter and see results immediately
- **Monaco Editor** - Full SQL syntax highlighting and IntelliSense
- **WASM-Powered** - Rust database compiled to WebAssembly
- **SQL Comment Support** - Use `--` for inline documentation
- **Export Results** - Copy to clipboard or download as CSV
- **Dark Mode** - Beautiful Tailwind CSS interface

**Try these queries**:
```sql
-- See all employees
SELECT * FROM employees;

-- Filter by department
SELECT name, salary FROM employees WHERE department = 'Engineering';

-- Aggregate data
SELECT department, COUNT(*) as count FROM employees GROUP BY department;
```

---

## üöÄ Quick Start

### Try the Demo Locally

```bash
# Clone the repository with submodules (includes SQLite reference source)
git clone --recurse-submodules https://github.com/rjwalters/vibesql.git
cd vibesql

# If already cloned, initialize submodules
git submodule update --init --recursive

# Run tests (requires Rust)
cargo test --workspace

# Run the interactive SQL shell (CLI)
cargo run -p cli

# Or run the web demo
cd web-demo
npm install
npm run dev
```

**Note**: This project includes SQLite source code as a reference submodule for learning and optimization. See [docs/reference/README.md](docs/reference/README.md) for details.

**Quick CLI Example**:
```bash
# Start the interactive shell
cargo run -p cli

# Run a quick query
vibesql> CREATE TABLE test (id INTEGER, name VARCHAR(50));
vibesql> INSERT INTO test VALUES (1, 'Hello'), (2, 'World');
vibesql> SELECT * FROM test;
vibesql> \q
```

See the [Interactive SQL Shell](#interactive-sql-shell) section below for complete CLI documentation.

### Python Usage

The database is also available as a Python library with DB-API 2.0 compatible interface:

```bash
# Build and install Python bindings (requires Python 3.8+, Rust)
pip install maturin
maturin develop

# Use in Python
python3
```

```python
import vibesql

# Create database connection
db = vibesql.connect()
cursor = db.cursor()

# Create table and insert data
cursor.execute("CREATE TABLE users (id INTEGER, name VARCHAR(50))")
cursor.execute("INSERT INTO users VALUES (1, 'Alice')")
cursor.execute("INSERT INTO users VALUES (2, 'Bob')")

# Query data
cursor.execute("SELECT * FROM users")
rows = cursor.fetchall()
for row in rows:
    print(row)  # (1, 'Alice'), (2, 'Bob')

# Close connections
cursor.close()
db.close()
```

**Python API Features**:
- DB-API 2.0 compatible interface
- Support for all SQL:1999 features
- Type conversion (Rust ‚Üí Python)
- `fetchone()`, `fetchall()`, `fetchmany()`
- Custom exception types
- Full transaction support

**Run Tests**:
```bash
python3 crates/python-bindings/tests/test_basic.py
```

**Benchmark Performance**:
```bash
python3 benchmarks/python_overhead.py
```

### Interactive SQL Shell

VibeSQL includes a full-featured command-line interface with multiple execution modes.

#### Installation & Basic Usage

```bash
# Build the CLI
cargo build --release -p cli

# Run in interactive mode (REPL)
cargo run -p cli

# Load existing database
cargo run -p cli -- --database mydb.sql

# Execute SQL from command line
cargo run -p cli -- --command "SELECT * FROM users"

# Execute SQL from file
cargo run -p cli -- --file queries.sql

# Execute SQL from stdin (pipe support)
echo "SELECT 1 + 1" | cargo run -p cli --

# Set output format
cargo run -p cli -- --format json --command "SELECT * FROM users"
```

#### Execution Modes

**1. Interactive REPL Mode (Default)**
```bash
vibesql> CREATE TABLE users (id INTEGER, name VARCHAR(50));
vibesql> INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
vibesql> SELECT * FROM users WHERE id = 1;
```

**2. Command Execution Mode**
```bash
# Execute single SQL command
vibesql -c "SELECT * FROM information_schema.tables"

# With custom format
vibesql -c "SELECT * FROM users" --format json
```

**3. File Execution Mode**
```bash
# Run all SQL commands from file
vibesql -f init.sql

# With verbose output
vibesql -f migration.sql --verbose
```

**4. Stdin Mode**
```bash
# Pipe SQL from another command
cat queries.sql | vibesql

# Use in shell scripts
echo "SELECT COUNT(*) FROM users" | vibesql --format csv
```

#### Meta-Commands

The CLI supports PostgreSQL-style meta-commands:

```bash
# Database introspection
\d                  # List all tables
\d users            # Describe table structure
\dt                 # List tables
\ds                 # List schemas
\di                 # List indexes
\du                 # List roles/users

# Output control
\f table            # Set output format to table (default)
\f json             # Set output format to JSON
\f csv              # Set output format to CSV
\f markdown         # Set output format to Markdown
\f html             # Set output format to HTML

# Data import/export
\copy users TO '/tmp/users.csv'         # Export table to CSV
\copy users TO '/tmp/users.json'        # Export table to JSON
\copy users FROM '/tmp/backup.csv'      # Import CSV data
\copy users FROM '/tmp/data.json'       # Import JSON data

# Database persistence
\save                      # Save to default location
\save mybackup.sql         # Save to specific file

# Utilities
\timing                    # Toggle query execution timing
\errors                    # Show recent error history
\h or \help               # Show help
\q or \quit               # Exit

# Examples
vibesql> \f json
Output format set to JSON

vibesql> SELECT * FROM users;
[{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]

vibesql> \timing
Timing is on

vibesql> SELECT COUNT(*) FROM large_table;
(10000 rows)
Time: 23.456 ms
```

#### Output Formats

Five output formats are supported:

**Table (Default)** - Pretty-printed ASCII table
```
+----+-------+
| id | name  |
+----+-------+
| 1  | Alice |
| 2  | Bob   |
+----+-------+
```

**JSON** - Newline-delimited JSON objects
```json
{"id": 1, "name": "Alice"}
{"id": 2, "name": "Bob"}
```

**CSV** - Comma-separated values with header
```csv
id,name
1,Alice
2,Bob
```

**Markdown** - Markdown table format
```markdown
| id | name  |
|----|-------|
| 1  | Alice |
| 2  | Bob   |
```

**HTML** - HTML table markup
```html
<table>
  <thead><tr><th>id</th><th>name</th></tr></thead>
  <tbody>
    <tr><td>1</td><td>Alice</td></tr>
    <tr><td>2</td><td>Bob</td></tr>
  </tbody>
</table>
```

#### Configuration File

Create `~/.vibesqlrc` to customize default behavior:

```toml
# Default output format
[output]
format = "table"  # Options: table, json, csv, markdown, html

# Database settings
[database]
default_path = "/path/to/default.sql"
auto_save = true
auto_save_path = "~/.vibesql_autosave.sql"

# Display settings
[display]
max_column_width = 50
show_row_count = true

# History settings
[history]
enabled = true
file_path = "~/.vibesql_history"
max_entries = 1000

# Performance
[performance]
query_timeout_ms = 30000
```

See `.vibesqlrc.example` for a complete configuration template.

#### CLI Features (Phase 5 Complete!)

‚úÖ **Interactive REPL** - Full readline support with history
‚úÖ **Multiple execution modes** - Interactive, command, file, stdin
‚úÖ **Meta-commands** - PostgreSQL-compatible \d, \dt, \ds, \di, \du commands
‚úÖ **Import/Export** - \copy command for CSV and JSON with validation
‚úÖ **Output formats** - Table, JSON, CSV, Markdown, HTML
‚úÖ **Configuration** - ~/.vibesqlrc for persistent preferences
‚úÖ **Persistence** - \save command with auto-save support
‚úÖ **Query timing** - \timing to measure execution performance
‚úÖ **Error tracking** - \errors to review recent failures
‚úÖ **Command history** - Persistent history with configurable size

**Advanced Examples**:

```bash
# Data pipeline with JSON output
vibesql -c "SELECT * FROM users" --format json | jq '.name'

# Generate HTML report
vibesql -f report_queries.sql --format html > report.html

# Quick CSV export
echo "SELECT * FROM sales WHERE year = 2024" | vibesql --format csv > sales_2024.csv

# Database migration workflow
vibesql -f schema.sql
vibesql -f seed_data.sql --verbose
vibesql -c "\save production.sql"
```

---

## üìñ Documentation

**User Guides**:
- **[docs/CLI_GUIDE.md](docs/CLI_GUIDE.md)** - Complete CLI user guide (meta-commands, import/export, configuration)
- **[docs/FEATURE_STATUS.md](docs/FEATURE_STATUS.md)** - Detailed feature breakdown
- **[.vibesqlrc.example](.vibesqlrc.example)** - Example configuration file

**Testing & Conformance**:
- **[SQL:1999 Conformance Report](https://rjwalters.github.io/vibesql/conformance.html)** - Live conformance test results
- [docs/testing/TESTING_STRATEGY.md](docs/testing/TESTING_STRATEGY.md) - Test approach and strategy
- [docs/sqllogictest/SQLLOGICTEST_QUICKSTART.md](docs/sqllogictest/SQLLOGICTEST_QUICKSTART.md) - SQLLogicTest quick start
- [docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md](docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md) - Conformance strategy

**Architecture & Design**:
- [docs/decisions/](docs/decisions/) - Architecture Decision Records
- [docs/lessons/TDD_APPROACH.md](docs/lessons/TDD_APPROACH.md) - TDD lessons learned
- [docs/lessons/LESSONS_LEARNED.md](docs/lessons/LESSONS_LEARNED.md) - Lessons learned

**Loom AI Orchestration**:
- [CLAUDE.md](CLAUDE.md) - AI-powered development guide
- [AGENTS.md](AGENTS.md) - Development agent workflows

---

## üéØ Design Principles

### What Makes This Project Unique

**1. Standards-First Approach**
- SQL:1999 specification is the source of truth
- NIST test suite validation
- No shortcuts or "close enough" implementations

**2. Educational Value**
- Comprehensive documentation of decisions
- TDD approach with 2,000+ tests
- Clear, readable Rust code
- Interactive web demo for learning

**3. Pragmatic Simplifications**
- In-memory only (no persistence)
- No performance requirements
- Single-threaded execution
- Focus: correctness over speed

**4. Research Goal**
- Target unprecedented FULL SQL:1999 compliance
- Document the journey and challenges
- Contribute to SQL implementation knowledge

---

## ü§ù Contributing

This project uses [Loom](https://github.com/loomhq/loom) for AI-powered development orchestration. See [CLAUDE.md](CLAUDE.md) for the development guide.

**Ways to Contribute**:
- üêõ Report bugs or missing features
- üìñ Improve documentation
- ‚ú® Implement optional SQL:1999 features
- üß™ Add SQLLogicTest coverage
- üåê Enhance the web demo
- üöÄ Improve performance

See [docs/WORK_PLAN.md](docs/WORK_PLAN.md) for current priorities.

---

## üìà Project Stats

- **Language**: Rust ü¶Ä
- **Code**: ~65,000 lines across 7-crate workspace
- **Tests**: 2,000+ unit/integration tests + 100% SQL:1999 Core conformance (739/739)
- **Coverage**: 86%
- **Development**: October 25 - November 1, 2025 (Core compliance in under 2 weeks)
- **Methodology**: Test-Driven Development (TDD)
- **Orchestration**: [Loom](https://github.com/loomhq/loom) AI framework
- **Status**: ‚úÖ Core Complete | üöß Extended Compliance In Progress

---

## üìú License

MIT License - See [LICENSE](LICENSE) for details.

---

## üôè Acknowledgments

- Inspired by the [posix4e/nistmemsql](https://github.com/posix4e/nistmemsql) challenge
- Built with [Loom](https://github.com/loomhq/loom) AI orchestration
- Powered by Rust ü¶Ä and Claude Code
- NIST SQL:1999 standard compliance guidance

---

**Try it now**: [Live Demo ‚Üí](https://rjwalters.github.io/vibesql/)

**Status**: ‚úÖ 100% SQL:1999 Core Conformance | üöß Extended Compliance In Progress
