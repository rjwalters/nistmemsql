# VibeSQL: AI-Powered SQL:1999 Database

[![CI and Deploy](https://github.com/rjwalters/vibesql/actions/workflows/ci-and-deploy.yml/badge.svg)](https://github.com/rjwalters/vibesql/actions/workflows/ci-and-deploy.yml)
[![Demo](https://img.shields.io/badge/demo-live-success)](https://rjwalters.github.io/vibesql/)
[![Coverage](https://img.shields.io/badge/coverage-86%25-green)](https://github.com/rjwalters/vibesql)
[![sqltest](https://img.shields.io/endpoint?url=https://rjwalters.github.io/vibesql/badges/sql1999-conformance.json)](https://rjwalters.github.io/vibesql/conformance.html)
[![SQLLogicTest](https://img.shields.io/endpoint?url=https://rjwalters.github.io/vibesql/badges/sqllogictest.json)](https://rjwalters.github.io/vibesql/conformance.html#SQLlogicTest)

> **VibeSQL - AI-powered, SQL:1999 database implementation in Rust**

üöÄ **[Try the Live Demo](https://rjwalters.github.io/vibesql/)** - Run SQL queries in your browser!

üíª **[Use the CLI](#interactive-sql-shell)** - Full-featured interactive SQL shell with import/export, multiple output formats, and PostgreSQL-compatible meta-commands!

---

## üéØ Project Vision

Build a **FULL SQL:1999 compliant** database from scratch, designed for NIST conformance testing. This is a research and educational project targeting complete standard compliance‚Äîsomething no production database has achieved.

### Achievement

**‚úÖ Core SQL:1999 Compliance - COMPLETE!**
- All ~169 mandatory Core features implemented
- 100% sqltest conformance (739/739 tests passing)
- Completed in under 2 weeks (Oct 25 - Nov 1, 2025)

**‚úÖ Extended SQL:1999 Compliance - COMPLETE**
- SQLLogicTest coverage: 628/628 files passing (100%, ~5.9M tests)
- All categories: DDL (100%), Evidence (100%), Index (100%), Select (100%), Random (100%), Debug (100%)
- Complete conformance achieved with 30-minute timeout for large index tests
- Inspired by the [posix4e/nistmemsql challenge](https://github.com/posix4e/nistmemsql)

**‚úÖ Advanced Database Features - COMPLETE!**
- Views with OR REPLACE and column lists
- Stored procedures & functions with parameter modes
- Spatial/geometric functions (complete ST_* library)
- Full-text search (MATCH AGAINST)
- Advanced indexing (REINDEX, spatial, fulltext)
- Completed Nov 1-12, 2025 (~2 weeks additional work)

---

## ü§ñ 100% AI-Generated

Every line of code, every test, and all documentation in this repository has been generated by AI agents using [Claude Code](https://claude.com/claude-code) and the [Loom orchestration framework](https://github.com/loomhq/loom).

**What was built:**
- üìä **171,000+ lines** of production Rust code across 7-crate workspace
- ‚úÖ **100% SQL:1999 Core compliance** (739/739 sqltest + 2,991 unit tests)
- ‚úÖ **100% SQLLogicTest suite** (628/628 files, ~5.9M tests passing)
- üöÄ **Full WASM compilation** with live browser demo
- üèóÔ∏è **AI Builder/Judge workflow** with automated PR reviews
- üîí **Complete security model** with privilege enforcement
- üóÇÔ∏è **Advanced database features**: Views, stored procedures/functions, spatial functions, full-text search
- üìà **Production-ready CLI** with PostgreSQL-compatible meta-commands and import/export

This demonstrates AI-primary development at scale‚Äîhigh-level intent translated directly into working, tested, standards-compliant software.

Learn more: [Loom documentation](https://github.com/loomhq/loom) and [working with AI](https://github.com/rjwalters/loom/blob/main/docs/philosophy/working-with-ai.md).

---

## üìä SQL:1999 Conformance Testing

We use comprehensive test suites to track SQL:1999 compliance:

### Test Suites
- **sqltest**: 739 BNF-driven tests from SQL:1999 standard (upstream-recommended)
- **Custom tests**: 2,991 unit tests for specific features
- **SQLLogicTest**: ~5.9 million tests from official SQLite corpus (628 test files)

### Current Conformance Status

| Suite | Tests | Status |
|-------|-------|--------|
| SQL:1999 sqltest | 739 tests | ‚úÖ **100% (739/739 passing)** |
| Custom Unit Tests | 2,991 tests | ‚úÖ **100% (2,991/2,991 passing)** |
| SQLLogicTest | 628 test files (~5.9M tests) | ‚úÖ **100% (628/628 passing)** - Complete conformance! |

**Major Features Implemented:**
- ‚úÖ **100% SQL:1999 Core Conformance** - All 739 sqltest tests passing
- ‚úÖ **100% SQLLogicTest Suite** - All 628 test files passing (~5.9M tests, complete conformance achieved!)
- ‚úÖ **Full-featured CLI** - Interactive REPL with PostgreSQL-compatible meta-commands
- ‚úÖ **Import/Export** - CSV and JSON support with \copy command
- ‚úÖ **Multiple output formats** - Table, JSON, CSV, Markdown, HTML
- ‚úÖ **Complete security model** - GRANT/REVOKE with full privilege enforcement
- ‚úÖ **Views** - Full CREATE/DROP VIEW support with OR REPLACE and column lists
- ‚úÖ **Stored Procedures & Functions** - CREATE PROCEDURE/FUNCTION with parameter modes (IN/OUT/INOUT)
- ‚úÖ **Spatial/Geometric Functions** - Complete ST_* function library (constructors, accessors, predicates)
- ‚úÖ **Full-Text Search** - MATCH AGAINST syntax with FULLTEXT index support
- ‚úÖ **Advanced Indexing** - REINDEX statement, composite indexes, and spatial indexes
- ‚úÖ **Performance optimizations** - Hash join, expression optimization, memory improvements

**See [SQL:1999 Conformance Report](https://rjwalters.github.io/vibesql/conformance.html) for detailed test results and remaining work.**

**See [Development Roadmap](docs/ROADMAP.md) for project status, upcoming milestones, and contribution priorities.**

---

## üöÄ Advanced Database Features

Beyond SQL:1999 Core compliance, VibeSQL implements advanced database features for real-world compatibility:

### Views (‚úÖ Complete)
Full CREATE VIEW support with SQL:1999 and MySQL extensions:
```sql
-- Basic view creation
CREATE VIEW active_users AS SELECT * FROM users WHERE status = 'active';

-- OR REPLACE for updates
CREATE OR REPLACE VIEW active_users AS SELECT id, name FROM users WHERE status = 'active';

-- Explicit column lists
CREATE VIEW user_summary (user_id, full_name) AS SELECT id, name FROM users;

-- IF NOT EXISTS clause
CREATE VIEW IF NOT EXISTS stats AS SELECT COUNT(*) as total FROM orders;
```

### Stored Procedures & Functions (‚úÖ Complete)
Procedural SQL with parameter modes (IN, OUT, INOUT):
```sql
-- Create a stored procedure
CREATE PROCEDURE update_salary(IN emp_id INT, IN amount DECIMAL)
BEGIN
    UPDATE employees SET salary = salary + amount WHERE id = emp_id;
END;

-- Create a function with return value
CREATE FUNCTION calculate_bonus(IN salary DECIMAL) RETURNS DECIMAL
BEGIN
    RETURN salary * 0.10;
END;

-- Parameters with IN/OUT/INOUT modes
CREATE PROCEDURE get_stats(IN dept_id INT, OUT emp_count INT, OUT avg_salary DECIMAL)
BEGIN
    SELECT COUNT(*), AVG(salary) INTO emp_count, avg_salary
    FROM employees WHERE department_id = dept_id;
END;
```

### Spatial/Geometric Functions (‚úÖ Complete)
Complete ST_* function library for geometric operations:
```sql
-- Constructors
SELECT ST_Point(1.0, 2.0);
SELECT ST_LineString(ST_Point(0,0), ST_Point(1,1), ST_Point(2,0));
SELECT ST_Polygon(ST_LineString(...));

-- Accessors
SELECT ST_X(ST_Point(5.0, 10.0));  -- Returns 5.0
SELECT ST_Y(ST_Point(5.0, 10.0));  -- Returns 10.0
SELECT ST_Length(geometry_column) FROM roads;

-- Spatial predicates
SELECT * FROM parcels WHERE ST_Contains(boundary, ST_Point(x, y));
SELECT ST_Intersects(geom1, geom2);
SELECT ST_Distance(point1, point2);

-- WKB format support with SRID tracking
SELECT ST_AsBinary(geometry_column) FROM spatial_table;
SELECT ST_GeomFromWKB(wkb_data, 4326);  -- With SRID
```

**Available spatial functions**:
- **Constructors**: ST_Point, ST_LineString, ST_Polygon, ST_GeomFromText, ST_GeomFromWKB
- **Accessors**: ST_X, ST_Y, ST_Length, ST_Area, ST_Centroid, ST_Envelope, ST_SRID
- **Predicates**: ST_Contains, ST_Within, ST_Intersects, ST_Crosses, ST_Overlaps, ST_Touches, ST_Equals, ST_Distance

### Full-Text Search (‚úÖ Complete)
MySQL-compatible MATCH AGAINST syntax:
```sql
-- Create FULLTEXT index
CREATE FULLTEXT INDEX ft_content ON articles(title, body);

-- Natural language search
SELECT * FROM articles
WHERE MATCH(title, body) AGAINST('database optimization');

-- Boolean mode search
SELECT * FROM articles
WHERE MATCH(title, body) AGAINST('+mysql -postgresql' IN BOOLEAN MODE);

-- With relevance scoring
SELECT title, MATCH(title, body) AGAINST('sql database') as relevance
FROM articles
WHERE MATCH(title, body) AGAINST('sql database')
ORDER BY relevance DESC;
```

### Advanced Indexing (‚úÖ Complete)
```sql
-- REINDEX statement for index maintenance
REINDEX TABLE users;
REINDEX INDEX idx_name;

-- Composite indexes
CREATE INDEX idx_user_location ON users(city, state, zip_code);

-- Spatial indexes for geometric data
CREATE SPATIAL INDEX idx_geom ON locations(geometry_column);

-- FULLTEXT indexes
CREATE FULLTEXT INDEX idx_search ON documents(title, content);
```

#### Indexed Column Prefix Syntax (MySQL/SQLite Compatibility)

VibeSQL supports MySQL/SQLite indexed column prefix syntax for compatibility:

```sql
CREATE TABLE users (email VARCHAR(255), UNIQUE (email(50)));
CREATE INDEX idx_email ON users (email(100));
```

**Current Status**: Syntax is parsed and accepted, but indexes currently operate on full column values. See issues #1623 and #1624 for future implementation.

### Non-Unique Indexes and Duplicate Keys (‚úÖ Complete)

VibeSQL fully supports non-unique indexes with duplicate key values:

```sql
-- Non-unique index (default - allows duplicates)
CREATE INDEX idx_department ON employees(department);

-- Composite non-unique indexes
CREATE INDEX idx_dept_salary ON employees(department, salary);
```

Both in-memory (HashMap) and disk-backed (B+ tree) implementations support efficient duplicate key storage. See `crates/vibesql-executor/src/tests/non_unique_disk_index_tests.rs` for implementation details.

### Triggers (üîÑ In Progress)
Event-driven database actions:
```sql
-- BEFORE trigger
CREATE TRIGGER audit_before_update
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log VALUES (OLD.id, OLD.salary, NEW.salary, NOW());
END;

-- AFTER trigger
CREATE TRIGGER sync_after_insert
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    UPDATE inventory SET quantity = quantity - NEW.quantity WHERE id = NEW.product_id;
END;
```

---

### üêï Dogfooding: SQLLogicTest Database Integration

**VibeSQL stores its own test results in VibeSQL!** Database-integrated workflow for ~5.9M test cases.

```bash
# Run tests (parallel mode recommended, 10-20 minutes on 8 CPUs)
./scripts/sqllogictest run --parallel --workers 8

# Query results with SQL
./scripts/sqllogictest query --preset failed-files
./scripts/sqllogictest query --preset by-category

# Test individual files
./scripts/sqllogictest test select1.test
```

**Documentation**: [Quick Start](docs/sqllogictest/SQLLOGICTEST_QUICKSTART.md) | [Complete Guide](docs/sqllogictest/SQLLOGICTEST_DATABASE.md)

### Running Tests

```bash
# Run all tests with coverage
cargo coverage

# Run comprehensive SQLLogicTest suite (recommended)
./scripts/sqllogictest run --parallel --workers 8

# Test individual files for debugging
./scripts/sqllogictest test random/select/slt_good_19.test
```

**Achievement**: 100% conformance (628/628 files, ~5.9M tests) using systematic punchlist approach. See [testing docs](docs/testing/sqllogictest/QUICK_START.md) for complete workflow.

---

## üìä Performance Benchmarking

Comprehensive benchmarking tools for the full SQLLogicTest suite (628 files, ~5.9M tests).

```bash
cd benchmarks/suite
./suite.sh                           # Full suite (3 iterations each)
./suite.sh --sample 50               # Sample 50 random files
./suite.sh --categories "select,random"  # Specific categories
```

**Recent Performance**: 87.45s total, 0.140s avg (628/628 passing, 100%)

See [benchmarks/suite/README.md](benchmarks/suite/README.md) for complete documentation.

---

## üí≠ Project Background

This project originated from a debate about AI capabilities in software development. [@rjwalters](https://github.com/rjwalters) argued that AI assistants like Claude Code have crossed an **inflection point** for complex software implementation. [@posix4e](https://github.com/posix4e) was skeptical, citing context window limitations.

The challenge: **"Implement a NIST-compatible SQL database from scratch."**

### Results

**‚úÖ Core SQL:1999 compliance achieved in under 2 weeks** (Oct 25 - Nov 1, 2025)
- 100% sqltest conformance (739/739 tests)
- 2,000+ unit/integration tests
- Complete query engine with all major SQL features
- Full transaction and constraint support
- Production-grade security model

### What This Demonstrates

- AI can handle complex, specification-driven projects
- Context window concerns can be managed with proper tooling ([Loom](https://github.com/loomhq/loom))
- Tedious, detail-oriented work (like SQL standard compliance) is well-suited to AI
- Productivity gains are orders of magnitude higher than traditional development

See [Working with AI](https://github.com/rjwalters/loom/blob/main/docs/philosophy/working-with-ai.md) for more on the philosophy.

---

## üó∫Ô∏è Roadmap

### ‚úÖ Core SQL:1999 Compliance - COMPLETE

**Achieved**: November 1, 2025 (Under 2 weeks from start)
- 100% sqltest conformance (739/739 tests)
- Complete query engine with all major SQL features
- Full transaction and constraint support
- Production-grade security model

### ‚úÖ Extended Compliance - COMPLETE

**SQLLogicTest Coverage - 100% (628/628 files)**
- ‚úÖ All 628 test files passing (~5.9M test cases)
- ‚úÖ All categories at 100%: DDL, Evidence, Debug, Index, Select, Random
- ‚úÖ Complete conformance achieved with 30-minute timeout for large index tests

**Optional SQL:1999 Features - Complete**
- ‚úÖ Information schema views
- ‚úÖ Advanced optimization techniques (hash joins, CSE, join reordering)
- ‚úÖ Comprehensive built-in function library
- ‚úÖ Views with OR REPLACE and column lists
- ‚úÖ Stored procedures and functions with parameter modes
- ‚úÖ Full-text search with MATCH AGAINST
- ‚úÖ Spatial/geometric functions (ST_* complete library)
- ‚úÖ Advanced indexing (REINDEX, composite, spatial)

### üéØ Future Directions

**Path 1: Advanced SQL:1999 Features**
- ‚úÖ ~~Stored procedures and functions~~ - COMPLETE
- ‚úÖ ~~Views~~ - COMPLETE
- Triggers (BEFORE/AFTER, row/statement level) - IN PROGRESS
- Advanced type system (ARRAY, ROW, UDT, BLOB, CLOB)
- Cursors and result set manipulation
- Advanced DDL (assertions, character sets, collations)
- Goal: First database with complete SQL:1999 compliance

**Path 2: MySQL/PostgreSQL Compatibility**
- ‚úÖ Full-text search (MATCH AGAINST) - COMPLETE
- ‚úÖ Spatial functions (ST_*) - COMPLETE
- ‚úÖ REINDEX statement - COMPLETE
- MySQL table options and DDL syntax
- PostgreSQL extensions and functions
- Cross-database compatibility layer

**Path 3: Production Readiness**
- ODBC/JDBC drivers
- Network protocol support
- Durable persistence layer with WAL
- Query planning and cost-based optimization
- Multi-threaded execution
- Production hardening and stability

**Path 4: Real-World Validation**
- TPC-H benchmarks
- Production workload testing
- Performance profiling and optimization
- Scalability improvements
- Memory efficiency enhancements

---

## üåê Live Demo

**[Try it now ‚Üí](https://rjwalters.github.io/vibesql/)**

Run SQL queries directly in your browser with **zero setup**:
- **Pre-loaded Sample Data** - 6 employee records ready to query
- **Instant Execution** - Press Ctrl/Cmd+Enter and see results immediately
- **Monaco Editor** - Full SQL syntax highlighting and IntelliSense
- **WASM-Powered** - Rust database compiled to WebAssembly
- **SQL Comment Support** - Use `--` for inline documentation
- **Export Results** - Copy to clipboard or download as CSV
- **Dark Mode** - Beautiful Tailwind CSS interface

**Try these queries**:
```sql
-- See all employees
SELECT * FROM employees;

-- Filter by department
SELECT name, salary FROM employees WHERE department = 'Engineering';

-- Aggregate data
SELECT department, COUNT(*) as count FROM employees GROUP BY department;
```

---

## üöÄ Quick Start

### Try the Demo Locally

```bash
# Clone the repository with submodules (includes SQLite reference source)
git clone --recurse-submodules https://github.com/rjwalters/vibesql.git
cd vibesql

# If already cloned, initialize submodules
git submodule update --init --recursive

# Run tests (requires Rust)
cargo test --workspace

# Run the interactive SQL shell (CLI)
cargo run -p vibesql-cli

# Or run the web demo
cd web-demo
npm install
npm run dev
```

**Note**: This project includes SQLite source code as a reference submodule for learning and optimization. See [docs/reference/README.md](docs/reference/README.md) for details.

**Quick CLI Example**:
```bash
# Start the interactive shell
cargo run -p vibesql-cli

# Run a quick query
vibesql> CREATE TABLE test (id INTEGER, name VARCHAR(50));
vibesql> INSERT INTO test VALUES (1, 'Hello'), (2, 'World');
vibesql> SELECT * FROM test;
vibesql> \q
```

See the [Interactive SQL Shell](#interactive-sql-shell) section below for complete CLI documentation.

### Python Usage

The database is also available as a Python library with DB-API 2.0 compatible interface:

```bash
# Build and install Python bindings (requires Python 3.8+, Rust)
pip install maturin
maturin develop

# Use in Python
python3
```

```python
import vibesql

# Create database connection
db = vibesql.connect()
cursor = db.cursor()

# Create table and insert data
cursor.execute("CREATE TABLE users (id INTEGER, name VARCHAR(50))")
cursor.execute("INSERT INTO users VALUES (1, 'Alice')")
cursor.execute("INSERT INTO users VALUES (2, 'Bob')")

# Query data
cursor.execute("SELECT * FROM users")
rows = cursor.fetchall()
for row in rows:
    print(row)  # (1, 'Alice'), (2, 'Bob')

# Close connections
cursor.close()
db.close()

# Database persistence - save to file
db2 = vibesql.connect()
cursor2 = db2.cursor()
cursor2.execute("CREATE TABLE products (id INTEGER, name VARCHAR(100))")
cursor2.execute("INSERT INTO products VALUES (1, 'Widget')")

# Save database to file
db2.save("/tmp/mydb.sql")

# Load database from file
db3 = vibesql.Database.load("/tmp/mydb.sql")
cursor3 = db3.cursor()
cursor3.execute("SELECT * FROM products")
print(cursor3.fetchall())  # [(1, 'Widget')]

cursor2.close()
db2.close()
cursor3.close()
db3.close()
```

**Python API Features**:
- DB-API 2.0 compatible interface
- Support for all SQL:1999 features
- Type conversion (Rust ‚Üí Python)
- `fetchone()`, `fetchall()`, `fetchmany()`
- Custom exception types
- Full transaction support
- Database persistence with `save()` and `load()` methods

**Run Tests**:
```bash
python3 crates/vibesql-python-bindings/tests/test_basic.py
```

**Benchmark Performance**:
```bash
python3 benchmarks/python_overhead.py
```

### Interactive SQL Shell

VibeSQL includes a full-featured command-line interface with multiple execution modes.

#### Installation & Basic Usage

```bash
# Build the CLI
cargo build --release -p vibesql-cli

# Run in interactive mode (REPL)
cargo run -p vibesql-cli

# Load existing database
cargo run -p vibesql-cli -- --database mydb.sql

# Execute SQL from command line
cargo run -p vibesql-cli -- --command "SELECT * FROM users"

# Execute SQL from file
cargo run -p vibesql-cli -- --file queries.sql

# Execute SQL from stdin (pipe support)
echo "SELECT 1 + 1" | cargo run -p vibesql-cli --

# Set output format
cargo run -p vibesql-cli -- --format json --command "SELECT * FROM users"
```

#### Execution Modes

**1. Interactive REPL Mode (Default)**
```bash
vibesql> CREATE TABLE users (id INTEGER, name VARCHAR(50));
vibesql> INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
vibesql> SELECT * FROM users WHERE id = 1;
```

**2. Command Execution Mode**
```bash
# Execute single SQL command
vibesql -c "SELECT * FROM information_schema.tables"

# With custom format
vibesql -c "SELECT * FROM users" --format json
```

**3. File Execution Mode**
```bash
# Run all SQL commands from file
vibesql -f init.sql

# With verbose output
vibesql -f migration.sql --verbose
```

**4. Stdin Mode**
```bash
# Pipe SQL from another command
cat queries.sql | vibesql

# Use in shell scripts
echo "SELECT COUNT(*) FROM users" | vibesql --format csv
```

#### Meta-Commands

The CLI supports PostgreSQL-style meta-commands:

```bash
# Database introspection
\d                  # List all tables
\d users            # Describe table structure
\dt                 # List tables
\ds                 # List schemas
\di                 # List indexes
\du                 # List roles/users

# Output control
\f table            # Set output format to table (default)
\f json             # Set output format to JSON
\f csv              # Set output format to CSV
\f markdown         # Set output format to Markdown
\f html             # Set output format to HTML

# Data import/export
\copy users TO '/tmp/users.csv'         # Export table to CSV
\copy users TO '/tmp/users.json'        # Export table to JSON
\copy users FROM '/tmp/backup.csv'      # Import CSV data
\copy users FROM '/tmp/data.json'       # Import JSON data

# Database persistence
\save                      # Save to default location
\save mybackup.sql         # Save to specific file

# Utilities
\timing                    # Toggle query execution timing
\errors                    # Show recent error history
\h or \help               # Show help
\q or \quit               # Exit

# Examples
vibesql> \f json
Output format set to JSON

vibesql> SELECT * FROM users;
[{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]

vibesql> \timing
Timing is on

vibesql> SELECT COUNT(*) FROM large_table;
(10000 rows)
Time: 23.456 ms
```

#### Output Formats

Five output formats are supported:

**Table (Default)** - Pretty-printed ASCII table
```
+----+-------+
| id | name  |
+----+-------+
| 1  | Alice |
| 2  | Bob   |
+----+-------+
```

**JSON** - Newline-delimited JSON objects
```json
{"id": 1, "name": "Alice"}
{"id": 2, "name": "Bob"}
```

**CSV** - Comma-separated values with header
```csv
id,name
1,Alice
2,Bob
```

**Markdown** - Markdown table format
```markdown
| id | name  |
|----|-------|
| 1  | Alice |
| 2  | Bob   |
```

**HTML** - HTML table markup
```html
<table>
  <thead><tr><th>id</th><th>name</th></tr></thead>
  <tbody>
    <tr><td>1</td><td>Alice</td></tr>
    <tr><td>2</td><td>Bob</td></tr>
  </tbody>
</table>
```

#### Configuration File

Create `~/.vibesqlrc` to customize default behavior:

```toml
# Default output format
[output]
format = "table"  # Options: table, json, csv, markdown, html

# Database settings
[database]
default_path = "/path/to/default.sql"
auto_save = true
auto_save_path = "~/.vibesql_autosave.sql"

# Display settings
[display]
max_column_width = 50
show_row_count = true

# History settings
[history]
enabled = true
file_path = "~/.vibesql_history"
max_entries = 1000

# Performance
[performance]
query_timeout_ms = 30000
```

See `.vibesqlrc.example` for a complete configuration template.

#### CLI Features (Phase 5 Complete!)

‚úÖ **Interactive REPL** - Full readline support with history
‚úÖ **Multiple execution modes** - Interactive, command, file, stdin
‚úÖ **Meta-commands** - PostgreSQL-compatible \d, \dt, \ds, \di, \du commands
‚úÖ **Import/Export** - \copy command for CSV and JSON with validation
‚úÖ **Output formats** - Table, JSON, CSV, Markdown, HTML
‚úÖ **Configuration** - ~/.vibesqlrc for persistent preferences
‚úÖ **Persistence** - \save command with auto-save support
‚úÖ **Query timing** - \timing to measure execution performance
‚úÖ **Error tracking** - \errors to review recent failures
‚úÖ **Command history** - Persistent history with configurable size

**Advanced Examples**:

```bash
# Data pipeline with JSON output
vibesql -c "SELECT * FROM users" --format json | jq '.name'

# Generate HTML report
vibesql -f report_queries.sql --format html > report.html

# Quick CSV export
echo "SELECT * FROM sales WHERE year = 2024" | vibesql --format csv > sales_2024.csv

# Database migration workflow
vibesql -f schema.sql
vibesql -f seed_data.sql --verbose
vibesql -c "\save production.sql"
```

---

## üîß Troubleshooting

### Build Errors

If you encounter compilation errors after switching branches or pulling updates, try a clean build:

```bash
cargo clean && cargo build --release
# Or use the convenience script
./scripts/clean-build.sh --release
```

For more help, see the [issue tracker](https://github.com/rjwalters/vibesql/issues).

---

## üìñ Documentation

**User Guides**:
- **[docs/CLI_GUIDE.md](docs/CLI_GUIDE.md)** - Complete CLI user guide (meta-commands, import/export, configuration)
- **[docs/reference/FEATURE_STATUS.md](docs/reference/FEATURE_STATUS.md)** - Detailed feature breakdown
- **[.vibesqlrc.example](.vibesqlrc.example)** - Example configuration file

**Testing & Conformance**:
- **[SQL:1999 Conformance Report](https://rjwalters.github.io/vibesql/conformance.html)** - Live conformance test results
- [docs/testing/TESTING_STRATEGY.md](docs/testing/TESTING_STRATEGY.md) - Test approach and strategy
- [docs/testing/sqllogictest/SQLLOGICTEST_QUICKSTART.md](docs/testing/sqllogictest/SQLLOGICTEST_QUICKSTART.md) - SQLLogicTest quick start
- [docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md](docs/roadmaps/PUNCHLIST_100_CONFORMANCE.md) - Conformance strategy

**Architecture & Design**:
- [docs/decisions/](docs/decisions/) - Architecture Decision Records
- [docs/lessons/TDD_APPROACH.md](docs/lessons/TDD_APPROACH.md) - TDD lessons learned
- [docs/lessons/LESSONS_LEARNED.md](docs/lessons/LESSONS_LEARNED.md) - Lessons learned

**Loom AI Orchestration**:
- [CLAUDE.md](CLAUDE.md) - AI-powered development guide
- [AGENTS.md](AGENTS.md) - Development agent workflows

---

## üéØ Design Principles

**Standards-First Approach**
- SQL:1999 specification is the source of truth
- NIST test suite validation
- No shortcuts or "close enough" implementations
- 100% Core SQL:1999 conformance achieved

**Educational & Research Value**
- Comprehensive documentation of decisions
- Test-driven development with 2,000+ tests
- Clear, readable Rust code
- Interactive web demo for learning
- Target: First database with FULL SQL:1999 compliance

**Practical Focus**
- Correctness over raw speed
- In-memory storage with SQL dump persistence
- Single-threaded execution model
- Performance optimizations where beneficial (hash joins, CSE, etc.)

---

## ü§ù Contributing

This project uses [Loom](https://github.com/loomhq/loom) for AI-powered development orchestration. See [CLAUDE.md](CLAUDE.md) for the development guide.

**Ways to Contribute**:
- üêõ Report bugs or missing features
- üìñ Improve documentation
- ‚ú® Implement optional SQL:1999 features
- üß™ Add SQLLogicTest coverage
- üåê Enhance the web demo
- üöÄ Improve performance

See the [roadmap](#-roadmap) section above for current priorities and completed milestones.

---

## üìà Project Stats

- **Language**: Rust ü¶Ä
- **Code**: ~171,000+ lines across 7-crate workspace
- **Tests**: 2,991 unit tests + 739 sqltest conformance + 628 SQLLogicTest files (~5.9M test cases)
- **Pass Rate**: 100% across all test suites (100% conformance achieved!)
- **Coverage**: 86%+
- **Development**: October 25 - November 19, 2025 (Full SQL:1999 + Advanced Features + 100% Conformance in ~4 weeks)
- **Methodology**: Test-Driven Development (TDD)
- **Orchestration**: [Loom](https://github.com/loomhq/loom) AI framework
- **Status**: ‚úÖ Core Complete | ‚úÖ 100% Extended Compliance | ‚úÖ Advanced Features Complete

---

## üìú License

MIT License - See [LICENSE](LICENSE) for details.

---

## üôè Acknowledgments

- Inspired by the [posix4e/nistmemsql](https://github.com/posix4e/nistmemsql) challenge
- Built with [Loom](https://github.com/loomhq/loom) AI orchestration
- Powered by Rust ü¶Ä and Claude Code
- NIST SQL:1999 standard compliance guidance

---

**Try it now**: [Live Demo ‚Üí](https://rjwalters.github.io/vibesql/)

**Status**: ‚úÖ 100% SQL:1999 Core Conformance | ‚úÖ 100% SQLLogicTest Suite (628/628 files, ~5.9M tests)
