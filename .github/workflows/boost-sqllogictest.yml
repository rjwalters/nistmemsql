name: Boost SQLLogicTest Coverage

on:
  workflow_dispatch:
    inputs:
      time_budget:
        description: 'Time budget in seconds (default: 300 = 5 minutes)'
        required: false
        default: '300'
        type: string
      run_count:
        description: 'Number of sequential test runs (default: 1)'
        required: false
        default: '1'
        type: string
      parallel_runners:
        description: 'Number of parallel runners (default: 1, max: 10)'
        required: false
        default: '1'
        type: string
  # Automatic hourly boost: 10 parallel workers for 10 minutes (only if work remains)
  schedule:
    - cron: '0 * * * *'  # Every hour

# Sets permissions for GitHub Pages deployment
permissions:
  contents: read
  pages: write
  id-token: write

# Prevent concurrent Pages deployments (queue them instead)
concurrency:
  group: pages-deployment
  cancel-in-progress: false

jobs:
  check-remaining-work:
    name: Check if there are untested files
    runs-on: ubuntu-latest
    # Only run this check for scheduled (cron) runs
    if: github.event_name == 'schedule'
    outputs:
      should_boost: ${{ steps.check.outputs.should_boost }}

    steps:
      - name: Download historical results
        id: check
        run: |
          echo "Checking if there are untested SQLLogicTest files..."

          # Default to boosting if we can't determine status
          SHOULD_BOOST="true"

          # Download cumulative results
          if curl -sL https://rjwalters.github.io/vibesql/badges/sqllogictest_cumulative.json \
            -o cumulative.json 2>/dev/null; then

            if jq empty cumulative.json 2>/dev/null; then
              COVERAGE=$(jq -r '.summary.coverage_rate // 0' cumulative.json)
              TESTED=$(jq -r '.summary.total_tested_files // 0' cumulative.json)
              AVAILABLE=$(jq -r '.summary.total_available_files // 0' cumulative.json)

              echo "Current coverage: ${COVERAGE}%"
              echo "Files tested: ${TESTED}/${AVAILABLE}"

              # Skip if coverage is 100%
              if [ "$COVERAGE" == "100.0" ] || [ "$TESTED" == "$AVAILABLE" ]; then
                echo "âœ“ Coverage is already 100% - no work remaining!"
                SHOULD_BOOST="false"
              else
                REMAINING=$((AVAILABLE - TESTED))
                echo "ðŸ“Š Found $REMAINING untested files - boost is needed"
                SHOULD_BOOST="true"
              fi
            else
              echo "âš ï¸  Invalid JSON - will run boost to establish baseline"
            fi
          else
            echo "âš ï¸  No historical data found - will run boost to establish baseline"
          fi

          echo "should_boost=$SHOULD_BOOST" >> $GITHUB_OUTPUT

  boost-coverage:
    name: Boost SQLLogicTest Coverage (Runner ${{ matrix.runner_id }})
    runs-on: ubuntu-latest
    # For manual runs: always run
    # For scheduled runs: only run if check-remaining-work says there's work to do
    needs: [check-remaining-work]
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' ||
       (github.event_name == 'schedule' && needs.check-remaining-work.outputs.should_boost == 'true'))
    strategy:
      fail-fast: false
      matrix:
        runner_id: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    steps:
      - name: Check if runner should execute
        id: should_run
        run: |
          # For scheduled runs: use 10 parallel runners
          # For manual runs: use the specified number (default 1)
          if [ "${{ github.event_name }}" == "schedule" ]; then
            PARALLEL_RUNNERS=10
          else
            PARALLEL_RUNNERS=${{ github.event.inputs.parallel_runners || '1' }}
          fi

          if [ ${{ matrix.runner_id }} -le $PARALLEL_RUNNERS ]; then
            echo "run=true" >> $GITHUB_OUTPUT
          else
            echo "run=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        if: steps.should_run.outputs.run == 'true'
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Rust
        if: steps.should_run.outputs.run == 'true'
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable

      - name: Cache Rust dependencies
        if: steps.should_run.outputs.run == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-boost-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-boost-
            ${{ runner.os }}-cargo-

      - name: Setup Python
        if: steps.should_run.outputs.run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Download historical SQLLogicTest results
        if: steps.should_run.outputs.run == 'true'
        continue-on-error: true
        run: |
          echo "Downloading historical SQLLogicTest results..."
          mkdir -p target

          # Download and validate JSON
          if curl -sL https://rjwalters.github.io/vibesql/badges/sqllogictest_cumulative.json \
            -o sqllogictest_cumulative.json 2>/dev/null; then

            # Check if it's valid JSON (not an HTML error page)
            if jq empty sqllogictest_cumulative.json 2>/dev/null; then
              echo "âœ“ Downloaded existing cumulative results"
              jq '.summary' sqllogictest_cumulative.json || echo "{}"
              cp sqllogictest_cumulative.json target/sqllogictest_historical.json
            else
              echo "Downloaded file is not valid JSON (likely 404 page) - starting fresh"
              echo '{}' > target/sqllogictest_historical.json
            fi
          else
            echo "No existing cumulative results found - starting fresh"
            echo '{}' > target/sqllogictest_historical.json
          fi

      - name: Run SQLLogicTest boost (multiple runs)
        if: steps.should_run.outputs.run == 'true'
        run: |
          # For scheduled runs: use 10 minutes (600 seconds)
          # For manual runs: use the specified time (default 5 minutes)
          if [ "${{ github.event_name }}" == "schedule" ]; then
            TIME_BUDGET="600"
            RUN_COUNT="1"
          else
            TIME_BUDGET="${{ github.event.inputs.time_budget || '300' }}"
            RUN_COUNT="${{ github.event.inputs.run_count || '1' }}"
          fi

          echo "=== Boost Configuration ==="
          echo "Time budget per run: ${TIME_BUDGET}s"
          echo "Number of runs: ${RUN_COUNT}"
          echo ""

          mkdir -p target/boost_runs

          RUNNER_ID="${{ matrix.runner_id }}"

          for i in $(seq 1 $RUN_COUNT); do
            echo ""
            echo "=== Runner $RUNNER_ID - Boost Run $i of $RUN_COUNT ==="

            # Use timestamp + runner_id + run number as seed for variety
            SEED=$(date +%s)${RUNNER_ID}${i}
            echo "Using seed: $SEED (runner $RUNNER_ID, run $i)"

            # Run tests with unique seed
            SQLLOGICTEST_SEED=$SEED timeout $((TIME_BUDGET + 30)) \
              cargo test --test sqllogictest_suite --release -- --nocapture 2>&1 | \
              tee target/boost_runs/run_${RUNNER_ID}_${i}.log | \
              python3 scripts/analyze_sqllogictest.py

            # Save this run's results
            if [ -f target/sqllogictest_analysis.json ]; then
              cp target/sqllogictest_analysis.json target/boost_runs/analysis_${RUNNER_ID}_${i}.json
              echo "âœ“ Saved analysis for run $i"
            fi

            # Merge with cumulative results after each run
            if [ -f target/sqllogictest_analysis.json ]; then
              echo "Merging run $i with cumulative results..."
              python3 scripts/merge_sqllogictest_results.py \
                target/sqllogictest_analysis.json \
                target/sqllogictest_historical.json \
                target/sqllogictest_cumulative_new.json

              # Update historical for next iteration
              if [ -f target/sqllogictest_cumulative_new.json ]; then
                cp target/sqllogictest_cumulative_new.json target/sqllogictest_historical.json
                cp target/sqllogictest_cumulative_new.json target/sqllogictest_cumulative.json
                echo "âœ“ Updated cumulative results"
                cat target/sqllogictest_cumulative.json | jq '.summary'
              fi
            fi

            echo ""
          done

          echo ""
          echo "=== Boost Complete ==="
          if [ -f target/sqllogictest_cumulative.json ]; then
            echo "Final cumulative results:"
            cat target/sqllogictest_cumulative.json | jq '.summary'
          fi
        env:
          SQLLOGICTEST_TIME_BUDGET: ${{ github.event.inputs.time_budget || '300' }}

      - name: Generate boost summary
        if: always() && steps.should_run.outputs.run == 'true'
        run: |
          # Determine parallel runners and time budget based on trigger
          if [ "${{ github.event_name }}" == "schedule" ]; then
            PARALLEL_RUNNERS=10
            TIME_BUDGET=600
            RUN_COUNT=1
            TRIGGER_TYPE="Scheduled (hourly cron)"
          else
            PARALLEL_RUNNERS=${{ github.event.inputs.parallel_runners || '1' }}
            TIME_BUDGET=${{ github.event.inputs.time_budget || '300' }}
            RUN_COUNT=${{ github.event.inputs.run_count || '1' }}
            TRIGGER_TYPE="Manual"
          fi

          echo "# SQLLogicTest Boost Run Summary (Runner ${{ matrix.runner_id }})" > boost_summary.md
          echo "" >> boost_summary.md
          echo "**Trigger:** $TRIGGER_TYPE" >> boost_summary.md
          echo "**Triggered by:** ${{ github.actor }}" >> boost_summary.md
          echo "**Time:** $(date -u)" >> boost_summary.md
          echo "**Runner ID:** ${{ matrix.runner_id }} / $PARALLEL_RUNNERS" >> boost_summary.md
          echo "**Time budget per run:** ${TIME_BUDGET}s" >> boost_summary.md
          echo "**Number of runs:** $RUN_COUNT" >> boost_summary.md
          echo "" >> boost_summary.md

          if [ -f target/sqllogictest_cumulative.json ]; then
            echo "## Cumulative Results" >> boost_summary.md
            echo "" >> boost_summary.md
            echo '```json' >> boost_summary.md
            cat target/sqllogictest_cumulative.json | jq '.summary' >> boost_summary.md
            echo '```' >> boost_summary.md
            echo "" >> boost_summary.md
            echo "**Coverage:** $(jq -r '.summary.coverage_rate' target/sqllogictest_cumulative.json)%" >> boost_summary.md
            echo "**Pass Rate:** $(jq -r '.summary.pass_rate' target/sqllogictest_cumulative.json)%" >> boost_summary.md
            echo "**Files Tested:** $(jq -r '.summary.total_tested_files' target/sqllogictest_cumulative.json) / $(jq -r '.summary.total_available_files' target/sqllogictest_cumulative.json)" >> boost_summary.md

            if [ -f target/sqllogictest_cumulative.json ]; then
              NEW_TESTED=$(jq -r '.merge_info.new_files_tested // 0' target/sqllogictest_cumulative.json)
              echo "**New files tested this boost:** $NEW_TESTED" >> boost_summary.md
            fi
          fi

          cat boost_summary.md

      - name: Upload boost results
        uses: actions/upload-artifact@v4
        if: always() && steps.should_run.outputs.run == 'true'
        with:
          name: boost-results-${{ github.run_number }}-runner-${{ matrix.runner_id }}
          path: |
            target/sqllogictest_cumulative.json
            target/sqllogictest_analysis.json
            target/boost_runs/*.json
            boost_summary.md
          retention-days: 90

  # Aggregation job: Collects results from all parallel runners and pushes once
  # IMPORTANT: This job downloads the FULL GitHub Pages site to preserve all
  # web demo files (HTML, JS, WASM, CSS) before updating only the cumulative
  # SQLLogicTest results. This prevents corrupting the web demo deployment.
  aggregate-results:
    name: Aggregate Results and Update gh-pages
    runs-on: ubuntu-latest
    needs: boost-coverage
    if: always() && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Download all runner artifacts for this run
        uses: actions/download-artifact@v4
        with:
          pattern: boost-results-${{ github.run_number }}-runner-*
          path: artifacts/
          merge-multiple: false

      - name: Download historical SQLLogicTest results
        continue-on-error: true
        run: |
          echo "Downloading historical cumulative results from gh-pages..."
          mkdir -p aggregated

          if curl -sL https://rjwalters.github.io/vibesql/badges/sqllogictest_cumulative.json \
            -o aggregated/sqllogictest_historical.json 2>/dev/null; then
            if jq empty aggregated/sqllogictest_historical.json 2>/dev/null; then
              echo "âœ“ Downloaded existing cumulative results"
              jq '.summary' aggregated/sqllogictest_historical.json
            else
              echo "Downloaded file is not valid JSON - starting fresh"
              echo '{}' > aggregated/sqllogictest_historical.json
            fi
          else
            echo "No existing cumulative results found - starting fresh"
            echo '{}' > aggregated/sqllogictest_historical.json
          fi

      - name: Merge all runner results
        run: |
          echo "=== Aggregating Results from All Runners ==="
          echo ""

          # Start with historical data
          cp aggregated/sqllogictest_historical.json aggregated/sqllogictest_merged.json

          # Find all runner result files
          RUNNER_FILES=$(find artifacts -name "sqllogictest_cumulative.json" | sort)
          RUNNER_COUNT=$(echo "$RUNNER_FILES" | wc -l | tr -d ' ')

          echo "Found $RUNNER_COUNT runner result files"
          echo ""

          # Merge each runner's results
          RUNNER_NUM=1
          for result_file in $RUNNER_FILES; do
            echo "Merging runner $RUNNER_NUM results..."

            python3 scripts/merge_sqllogictest_results.py \
              "$result_file" \
              aggregated/sqllogictest_merged.json \
              aggregated/sqllogictest_merged_new.json

            if [ -f aggregated/sqllogictest_merged_new.json ]; then
              mv aggregated/sqllogictest_merged_new.json aggregated/sqllogictest_merged.json
              echo "âœ“ Merged runner $RUNNER_NUM"
            fi

            RUNNER_NUM=$((RUNNER_NUM + 1))
          done

          echo ""
          echo "=== Final Aggregated Results ==="
          jq '.summary' aggregated/sqllogictest_merged.json

      - name: Download current Pages site
        run: |
          echo "Downloading current Pages site content..."
          mkdir -p pages-site

          # Download the entire current Pages site recursively
          # -r: recursive, -np: no parent, -nH: no host directory
          # -E: adjust extension, -k: convert links
          # -A: accept specific file types to ensure all assets are downloaded
          # --reject: reject patterns we don't want
          wget -r -np -nH -E -k --cut-dirs=0 \
            -A "*.html,*.js,*.wasm,*.css,*.json,*.svg,*.png,*.jpg,*.jpeg,*.gif,*.woff,*.woff2,*.ttf,*.eot,*.ico,*.md" \
            --reject "*.html.tmp,*.html?*" \
            -P pages-site \
            https://rjwalters.github.io/vibesql/ || {
            echo "âš ï¸  Could not download full Pages site"
            echo "This might be the first boost run - creating minimal structure"
            mkdir -p pages-site/vibesql/badges
          }

          # Explicitly download the /pkg/ directory (WASM files not linked in HTML)
          echo ""
          echo "Downloading /pkg/ directory with WASM files..."
          mkdir -p pages-site/vibesql/pkg
          wget -q -P pages-site/vibesql/pkg \
            https://rjwalters.github.io/vibesql/pkg/vibesql_wasm_bg.wasm \
            https://rjwalters.github.io/vibesql/pkg/vibesql_wasm.js \
            https://rjwalters.github.io/vibesql/pkg/package.json || {
            echo "âš ï¸  Could not download pkg directory - may not exist yet"
          }

          # Clean up wget artifacts
          rm -f pages-site/robots.txt.tmp 2>/dev/null || true
          rm -f pages-site/.listing 2>/dev/null || true

          echo ""
          echo "=== Downloaded Pages site structure ==="
          find pages-site -type f | head -30
          echo ""
          echo "=== JavaScript and WASM files ==="
          find pages-site -name "*.js" -o -name "*.wasm" | head -20
          echo ""
          echo "=== Key asset counts ==="
          echo "HTML files: $(find pages-site -name "*.html" | wc -l)"
          echo "JS files: $(find pages-site -name "*.js" | wc -l)"
          echo "WASM files: $(find pages-site -name "*.wasm" | wc -l)"
          echo "CSS files: $(find pages-site -name "*.css" | wc -l)"
          echo "JSON files: $(find pages-site -name "*.json" | wc -l)"

      - name: Verify downloaded site integrity
        run: |
          echo "=== Verifying critical files exist ==="

          # Check for essential HTML files
          if [ ! -f pages-site/vibesql/index.html ]; then
            echo "âŒ ERROR: index.html not found! Site download may have failed."
            echo "This could corrupt the deployment. Aborting to preserve current site."
            exit 1
          fi

          # Check for WASM files (critical for database functionality)
          WASM_COUNT=$(find pages-site/vibesql -name "*.wasm" 2>/dev/null | wc -l | tr -d ' ')
          if [ "$WASM_COUNT" -eq 0 ]; then
            echo "âŒ ERROR: No WASM files found! Database will not function."
            echo "This could corrupt the deployment. Aborting to preserve current site."
            exit 1
          fi

          # Check for JavaScript files
          JS_COUNT=$(find pages-site/vibesql -name "*.js" 2>/dev/null | wc -l | tr -d ' ')
          if [ "$JS_COUNT" -eq 0 ]; then
            echo "âŒ ERROR: No JavaScript files found! Site will not function."
            echo "This could corrupt the deployment. Aborting to preserve current site."
            exit 1
          fi

          echo "âœ“ Found index.html"
          echo "âœ“ Found $WASM_COUNT WASM files"
          echo "âœ“ Found $JS_COUNT JavaScript files"
          echo ""
          echo "Site integrity check PASSED"

      - name: Update cumulative results in Pages site
        run: |
          if [ ! -f aggregated/sqllogictest_merged.json ]; then
            echo "No aggregated results to publish"
            exit 1
          fi

          # Create badges directory if it doesn't exist
          mkdir -p pages-site/vibesql/badges

          # Copy aggregated results
          cp aggregated/sqllogictest_merged.json pages-site/vibesql/badges/sqllogictest_cumulative.json

          echo ""
          echo "=== Updated Cumulative Results ==="
          jq '.summary' pages-site/vibesql/badges/sqllogictest_cumulative.json

          # Generate badge JSON from cumulative results
          echo ""
          echo "=== Generating Badge JSON ==="
          SLT_PASS_RATE=$(jq -r '.summary.pass_rate // "0"' pages-site/vibesql/badges/sqllogictest_cumulative.json | xargs printf "%.1f")
          SLT_COVERAGE=$(jq -r '.summary.coverage_rate // "0"' pages-site/vibesql/badges/sqllogictest_cumulative.json | xargs printf "%.1f")
          SLT_PASSED=$(jq -r '.summary.passed // "0"' pages-site/vibesql/badges/sqllogictest_cumulative.json)
          SLT_FAILED=$(jq -r '.summary.failed // "0"' pages-site/vibesql/badges/sqllogictest_cumulative.json)

          # Determine badge color (based on coverage rate)
          if (( $(echo "$SLT_COVERAGE >= 80" | bc -l) )); then
            SLT_COLOR="brightgreen"
          elif (( $(echo "$SLT_COVERAGE >= 60" | bc -l) )); then
            SLT_COLOR="green"
          elif (( $(echo "$SLT_COVERAGE >= 40" | bc -l) )); then
            SLT_COLOR="yellow"
          elif (( $(echo "$SLT_COVERAGE >= 20" | bc -l) )); then
            SLT_COLOR="orange"
          else
            SLT_COLOR="red"
          fi

          # Create SQLLogicTest badge JSON (showing coverage)
          cat > pages-site/vibesql/badges/sqllogictest.json <<JSON
          {
            "schemaVersion": 1,
            "label": "SQLLogicTest",
            "message": "${SLT_PASSED}âœ“ ${SLT_FAILED}âœ— (${SLT_COVERAGE}% tested)",
            "color": "$SLT_COLOR"
          }
          JSON

          echo "Generated SQLLogicTest badge: ${SLT_PASSED}âœ“ ${SLT_FAILED}âœ— (${SLT_COVERAGE}% coverage, $SLT_COLOR)"
          echo ""
          echo "Badge JSON:"
          cat pages-site/vibesql/badges/sqllogictest.json

          echo ""
          echo "=== Pages site structure ==="
          ls -la pages-site/vibesql/
          echo ""
          echo "=== Badges directory ==="
          ls -la pages-site/vibesql/badges/ || echo "No badges directory"

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './pages-site/vibesql'

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4
