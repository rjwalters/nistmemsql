name: SQLLogicTest PR Comment

on:
  workflow_run:
    workflows: ["CI and Deploy"]
    types:
      - completed

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  comment-on-pr:
    name: Comment test results on PR
    runs-on: ubuntu-latest
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download test results artifact
        uses: actions/download-artifact@v4
        with:
          name: sqllogictest-results
          path: test-results
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Get PR number
        id: get-pr
        uses: actions/github-script@v8
        with:
          script: |
            const pulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
            });

            if (pulls.data.length > 0) {
              core.setOutput('pr-number', pulls.data[0].number);
              return pulls.data[0].number;
            }
            return null;

      - name: Get baseline results
        id: baseline
        run: |
          # Try to get previous cumulative results from main branch
          if [ -f "target/sqllogictest_cumulative.json" ]; then
            cp target/sqllogictest_cumulative.json baseline.json
            echo "has-baseline=true" >> $GITHUB_OUTPUT
          else
            echo "has-baseline=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect regressions
        id: regressions
        if: steps.baseline.outputs.has-baseline == 'true'
        run: |
          python3 scripts/detect_test_regressions.py \
            baseline.json \
            test-results/sqllogictest_cumulative.json \
            --format json \
            --output regressions.json

          # Extract key metrics for use in comment
          CURRENT_PASS_RATE=$(jq -r '.summary.current_pass_rate' regressions.json)
          PASS_RATE_CHANGE=$(jq -r '.summary.pass_rate_change' regressions.json)
          FIXED_COUNT=$(jq -r '.changes.fixed_tests | length' regressions.json)
          REGRESSION_COUNT=$(jq -r '.changes.regressions | length' regressions.json)
          NEW_FAILURE_COUNT=$(jq -r '.changes.new_failures | length' regressions.json)

          echo "pass-rate=$CURRENT_PASS_RATE" >> $GITHUB_OUTPUT
          echo "pass-rate-change=$PASS_RATE_CHANGE" >> $GITHUB_OUTPUT
          echo "fixed=$FIXED_COUNT" >> $GITHUB_OUTPUT
          echo "regressions=$REGRESSION_COUNT" >> $GITHUB_OUTPUT
          echo "new-failures=$NEW_FAILURE_COUNT" >> $GITHUB_OUTPUT

      - name: Generate PR comment
        id: comment
        uses: actions/github-script@v8
        if: steps.get-pr.outputs.pr-number != null
        with:
          script: |
            const fs = require('fs');

            let body = '## SQLLogicTest Results\n\n';

            // Check if we have regression data
            if ('${{ steps.baseline.outputs.has-baseline }}' === 'true') {
              const passRate = '${{ steps.regressions.outputs.pass-rate }}';
              const change = parseFloat('${{ steps.regressions.outputs.pass-rate-change }}');
              const fixed = parseInt('${{ steps.regressions.outputs.fixed }}');
              const regressions = parseInt('${{ steps.regressions.outputs.regressions }}');
              const newFailures = parseInt('${{ steps.regressions.outputs.new-failures }}');

              // Pass rate with change indicator
              body += `**Pass Rate**: ${passRate}% `;
              if (change > 0) {
                body += `(+${change.toFixed(2)}% ‚úÖ)\n\n`;
              } else if (change < 0) {
                body += `(${change.toFixed(2)}% ‚ùå)\n\n`;
              } else {
                body += `(unchanged)\n\n`;
              }

              // Changes summary
              body += '**Changes:**\n';
              body += `- ‚úÖ Fixed: ${fixed} tests\n`;

              if (regressions > 0) {
                body += `- ‚ùå Regressions: ${regressions} tests (tests that were passing, now failing)\n`;
              }

              if (newFailures > 0) {
                body += `- üÜï New failures: ${newFailures} tests\n`;
              }

              body += '\n';

              // Read detailed regression report if available
              if (fs.existsSync('regressions.json')) {
                const data = JSON.parse(fs.readFileSync('regressions.json', 'utf8'));

                // Show regressions in detail
                if (data.changes.regressions && data.changes.regressions.length > 0) {
                  body += '<details>\n';
                  body += '<summary>‚ö†Ô∏è Regression Details</summary>\n\n';
                  body += 'These tests were passing before but are now failing:\n\n';
                  const toShow = data.changes.regressions.slice(0, 10);
                  toShow.forEach(test => {
                    body += `- \`${test}\`\n`;
                  });
                  if (data.changes.regressions.length > 10) {
                    body += `- ... and ${data.changes.regressions.length - 10} more\n`;
                  }
                  body += '</details>\n\n';
                }

                // Show fixed tests
                if (data.changes.fixed_tests && data.changes.fixed_tests.length > 0) {
                  body += '<details>\n';
                  body += '<summary>‚úÖ Fixed Tests</summary>\n\n';
                  const toShow = data.changes.fixed_tests.slice(0, 10);
                  toShow.forEach(test => {
                    body += `- \`${test}\`\n`;
                  });
                  if (data.changes.fixed_tests.length > 10) {
                    body += `- ... and ${data.changes.fixed_tests.length - 10} more\n`;
                  }
                  body += '</details>\n\n';
                }
              }
            } else {
              // No baseline available
              body += '_No baseline results available for comparison._\n\n';

              // Show basic current stats if available
              if (fs.existsSync('test-results/sqllogictest_cumulative.json')) {
                const current = JSON.parse(fs.readFileSync('test-results/sqllogictest_cumulative.json', 'utf8'));
                const summary = current.summary || {};

                body += `**Current Results:**\n`;
                body += `- Pass Rate: ${summary.pass_rate || 0}%\n`;
                body += `- Tests Passing: ${summary.passed || 0}\n`;
                body += `- Tests Failing: ${summary.failed || 0}\n`;
                body += `- Coverage: ${summary.coverage_rate || 0}%\n`;
              }
            }

            // Add link to full analysis if available
            body += '\n---\n';
            body += '_For detailed failure analysis, see the full test report in the workflow artifacts._';

            return body;

      - name: Post or update PR comment
        uses: actions/github-script@v8
        if: steps.get-pr.outputs.pr-number != null
        with:
          script: |
            const prNumber = parseInt('${{ steps.get-pr.outputs.pr-number }}');
            const body = ${{ steps.comment.outputs.result }};

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('## SQLLogicTest Results')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body
              });
            }
