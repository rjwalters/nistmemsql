# Issue #1807: BTreeMap Ordering Issues
#
# TECHNICAL DETAILS:
# The index uses BTreeMap<Vec<SqlValue>, Vec<usize>> for storage.
# BTreeMap ordering for Vec<T> is lexicographic:
# - [10] < [10, 20] (shorter vector is less than longer with same prefix)
# - [10, 20] < [10, 30] (compares second element when first is equal)
# - [20, 40] > [10, 30] (first element determines order)
#
# The range_scan() method uses BTreeMap::range() which requires proper
# bounds. When searching for a IN (10), we want ALL keys starting with 10,
# but BTreeMap::range([10]..=[10]) only matches exactly [10], not [10, 20].
#
# SOLUTION: Implement prefix matching by detecting equality bounds and
# iterating through the index comparing only the first column.
#
# PERFORMANCE ISSUE: Current fix uses O(n) iteration instead of O(log n)
# BTreeMap::range(). Proper solution requires calculating correct upper
# bound: range([10]..=[10, MAX_VALUE]) or similar approach.

statement ok
CREATE TABLE test(pk INTEGER PRIMARY KEY, a INTEGER, b INTEGER, c INTEGER)

statement ok
CREATE INDEX idx_abc ON test (a, b, c)

statement ok
INSERT INTO test VALUES (1, 10, 20, 30)

statement ok
INSERT INTO test VALUES (2, 10, 20, 40)

statement ok
INSERT INTO test VALUES (3, 10, 30, 50)

statement ok
INSERT INTO test VALUES (4, 20, 40, 60)

# Test prefix matching on first column
# Index keys: [10,20,30], [10,20,40], [10,30,50], [20,40,60]
# Search for: a IN (10)
# Should match: [10,20,30], [10,20,40], [10,30,50]
query I rowsort
SELECT pk FROM test WHERE a IN (10)
----
1
2
3

# Test that BTreeMap ordering is correct for exact matches
# This works even without the fix because it's exact key lookup
query I rowsort
SELECT pk FROM test WHERE a = 10 AND b = 20
----
1
2

# Test that demonstrates the BTreeMap range issue
# Without prefix matching fix, this fails because:
# - range_scan([10]..=[10]) doesn't match [10,20,30]
# - BTreeMap sees [10] < [10,20,30] so it's not in range
query I rowsort
SELECT pk FROM test WHERE a IN (10, 20)
----
1
2
3
4

# Verify that ordering within results is correct
# Results should be in index order (BTreeMap order), not row index order
query III nosort
SELECT pk, a, b FROM test WHERE a IN (10) ORDER BY a, b
----
1 10 20
2 10 20
3 10 30

# Test with three-column index and IN on first column
# This is the most complex case for prefix matching
statement ok
CREATE TABLE multi3(pk INTEGER PRIMARY KEY, x INTEGER, y INTEGER, z INTEGER)

statement ok
CREATE INDEX idx_xyz ON multi3 (x, y, z)

statement ok
INSERT INTO multi3 VALUES (1, 5, 10, 15)

statement ok
INSERT INTO multi3 VALUES (2, 5, 10, 20)

statement ok
INSERT INTO multi3 VALUES (3, 5, 20, 25)

statement ok
INSERT INTO multi3 VALUES (4, 10, 30, 35)

query I rowsort
SELECT pk FROM multi3 WHERE x IN (5)
----
1
2
3
