# Issue #1807: Predicate Pushdown Incompatibility
#
# ARCHITECTURAL CONFLICT:
# 1. Index optimization (execute_without_aggregation) relies on row indices
#    that correspond to positions in the FROM result
# 2. Predicate pushdown (execute_from_with_where) filters rows early,
#    changing row indices before the index optimization runs
# 3. This causes index optimization to receive 0 rows or incorrect indices
#
# TEMPORARY FIX: Disable predicate pushdown globally
# PERFORMANCE IMPACT: ALL queries lose predicate pushdown optimization
#
# PROPER SOLUTION: Move index optimization to the scan/FROM level where
# it can be applied during table scanning, before row indices are assigned.

statement ok
CREATE TABLE test(pk INTEGER PRIMARY KEY, a INTEGER, b INTEGER)

statement ok
CREATE INDEX idx_test ON test (a, b)

statement ok
INSERT INTO test VALUES (1, 10, 20)

statement ok
INSERT INTO test VALUES (2, 10, 30)

statement ok
INSERT INTO test VALUES (3, 20, 40)

statement ok
INSERT INTO test VALUES (4, 30, 50)

statement ok
INSERT INTO test VALUES (5, 30, 60)

# Test combining IN with other predicates
# This demonstrates the predicate pushdown conflict
# EXPECTED: Returns rows where a IN (10, 20) AND b > 25
query I rowsort
SELECT pk FROM test WHERE a IN (10, 20) AND b > 25
----
2
3

# Test with OR condition
# EXPECTED: Returns rows where a IN (10) OR b = 60
query I rowsort
SELECT pk FROM test WHERE a IN (10) OR b = 60
----
1
2
5

# Test with complex WHERE clause
# This would benefit most from predicate pushdown, but can't have it
# with the temporary fix
query I rowsort
SELECT pk FROM test WHERE a IN (10, 30) AND b < 40
----
1
2

# Performance regression test: This query should use predicate pushdown
# to filter rows early, but with the temporary fix it cannot
# EXPECTED: Should return rows efficiently
# ACTUAL (with temp fix): Scans all rows, then filters
query I rowsort
SELECT pk FROM test WHERE a IN (20) AND pk > 2
----
3
