# Issue #1807: Multi-column IN clause optimization
#
# PROBLEM: When using an IN clause on the first column of a multi-column index,
# the query returns 0 rows instead of the expected results.
#
# ROOT CAUSE: The index optimization code uses range_scan() which compares
# single-element keys [10] against multi-element keys [10, 20], [10, 30].
# BTreeMap ordering treats [10] < [10, 20] because shorter vectors compare
# as less than longer vectors with the same prefix.
#
# ARCHITECTURAL ISSUE: The fix requires prefix matching in range_scan(),
# but this creates a conflict with predicate pushdown optimization.
# The index optimization needs ALL rows to preserve correct row indices,
# but predicate pushdown filters rows early for performance.
#
# This test documents the expected behavior once the architectural issues
# are resolved.

statement ok
CREATE TABLE test(pk INTEGER PRIMARY KEY, a INTEGER, b INTEGER)

statement ok
CREATE INDEX idx_test ON test (a, b)

statement ok
INSERT INTO test VALUES (1, 10, 20)

statement ok
INSERT INTO test VALUES (2, 10, 30)

statement ok
INSERT INTO test VALUES (3, 20, 40)

# Test 1: Single value IN clause on first column of multi-column index
# EXPECTED: Should return rows 1 and 2 (both have a=10)
# WITHOUT FIX: Returns 0 rows
query I rowsort
SELECT pk FROM test WHERE a IN (10)
----
1
2

# Test 2: Multiple values IN clause on first column
# EXPECTED: Should return all rows (a IN (10, 20))
# WITHOUT FIX: Returns 0 rows
query I rowsort
SELECT pk FROM test WHERE a IN (10, 20)
----
1
2
3

# Test 3: IN clause with non-existent value
# EXPECTED: Should return 0 rows
query I rowsort
SELECT pk FROM test WHERE a IN (99)
----

# Test 4: IN clause mixed with other columns in SELECT
# EXPECTED: Should return both a and b values for matching rows
query II rowsort
SELECT a, b FROM test WHERE a IN (10)
----
10 20
10 30
